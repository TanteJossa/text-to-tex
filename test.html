<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LaTeX Live Preview</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.css" crossorigin="anonymous">
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/katex.min.js" crossorigin="anonymous"></script>
    <script defer src="https://cdn.jsdelivr.net/npm/katex@0.16.9/dist/contrib/auto-render.min.js"
        crossorigin="anonymous" onload="renderMathInElement(document.body);"></script>
    <style>
        body {
            font-family: sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        #input {
            width: 80%;
            min-height: 100px;
            padding: 10px;
            border: 1px solid #ccc;
            margin-bottom: 20px;
            font-size: 16px;
            resize: vertical;
        }

        .output-container {
            width: 80%;
            display: flex;
            justify-content: space-between;
            gap: 20px;
        }

        .output-section {
            border: 1px solid #ccc;
            padding: 10px;
            width: 48%;
            /* Adjust width as needed */
            min-height: 50px;
        }

        #katex-output {
            font-size: 1.2em;
        }

        #raw-tex-output {
            font-family: monospace;
        }

        #error-message {
            color: red;
        }
    </style>
</head>

<body>
    <h1>LaTeX Live Preview</h1>

    <textarea id="input" placeholder="Enter your expression here..."></textarea>
    <div id="error-message"></div>

    <div class="output-container">
        <div class="output-section" id="katex-output"></div>
        <div class="output-section" id="raw-tex-output"></div>
    </div>
    <div class="output-container">
        <div class="output-section" id="text-output"></div>
    </div>

    <script>
        function convertBlocksToLatex(blocks, isUnit = false) {
            if (!Array.isArray(blocks)) {
                blocks = [blocks];
            }

            const functionsWithSubscriptsAndSuperscripts = ['int', 'sum'];
            const functionsWithSubscripts = ['log'];
            const functionsWithOneSubscript = ['lim', 'liminf', 'limsup'];
            const functionsWithNoSubscripts = ['sqrt', 'abs', 'ln', 'sin', 'cos', 'tan', 'cot', 'sec', 'csc', 'arcsin', 'arccos', 'arctan', 'arg', 'deg', 'det', 'dim', 'exp', 'gcd', 'hom', 'inf', 'ker', 'lg', 'max', 'min', 'Pr', 'sinh', 'tanh', 'coth'];

            function convertBlock(block, isUnit) {
                if (block.type === 'number') {
                    let value = block.value.replace('.', ',').replace(',', '{,}');
                    if (value.includes('E')) {
                        const [base, exp] = value.split('E');
                        return `${base} \\cdot 10^{${exp}}`;
                    }
                    return value;
                } else if (block.type === 'operator') {
                    switch (block.value) {
                        case '+': return ' + ';
                        case '-': return ' - ';
                        case '*': return ' \\cdot ';
                        case '/': return ' \\dfrac{';
                        default: return block.value; // For equallike operators
                    }
                } else if (block.type === 'variable') {
                    return isUnit ? `\\text{ ${block.value.replace(/({|})/g, '\\$1')}}` : block.value.replace(/({|})/g, '\\$1');
                } else if (block.type === 'text') {
                    return `\\text{${block.value}}`;
                } else if (block.type === 'braces') {
                    return `{${convertBlocksToLatex(block.blocks, isUnit)}}`;
                } else if (block.type === 'brackets') {
                    const unitBlocks = convertBlocksToLatex(block.blocks, true);
                    return ` ${unitBlocks}`;
                } else if (block.type === 'function') {
                    if (block.sub_eq) {
                        const sub_eq = block.sub_eq.map(eq => convertBlocksToLatex(eq, isUnit));
                        if (functionsWithSubscriptsAndSuperscripts.includes(block.name)) {
                            const first = sub_eq[sub_eq.length - 1];
                            const second = sub_eq.length > 1 ? sub_eq[sub_eq.length - 2] : null;
                            const third = sub_eq.length > 2 ? sub_eq[sub_eq.length - 3] : null;
                            return `\\${block.name}${third ? `_{${third}}` : ''}${second ? `^{${second}}` : ''}{${first}}`;
                        } else if (functionsWithSubscripts.includes(block.name)) {
                            const first = sub_eq[sub_eq.length - 1];
                            const second = sub_eq.length > 1 ? sub_eq[sub_eq.length - 2] : '';
                            return `\\${block.name}${second ? `_{${second}}` : ''}{${first}}`;
                        } else if (functionsWithOneSubscript.includes(block.name)) {
                            const first = sub_eq[sub_eq.length - 1];
                            const second = sub_eq.length > 1 ? sub_eq[sub_eq.length - 2] : '';
                            return `\\${block.name}${second ? `_{${second}}` : ''}({${first}})`;
                        } else {
                            const first = sub_eq[sub_eq.length - 1];
                            return `\\${block.name}({${first}})`;
                        }
                    } else {
                        return `\\${block.name}({})`;
                    }
                }
                return '';
            }

            let latex = '';
            for (let i = 0; i < blocks.length; i++) {
                const block = blocks[i];
                if (block && block.type === 'operator' && block.value === '/') {
                    // Handle division specially
                    const numerator = convertBlock(blocks[i - 1], isUnit);
                    const denominator = convertBlock(blocks[i + 1], isUnit);
                    latex = latex.slice(0, -convertBlock(blocks[i - 1], isUnit).length); // Remove the last added numerator
                    latex += `\\dfrac{${numerator}}{${denominator}}`;
                    i++; // Skip the denominator block
                } else if (block.type === 'whitespace') {
                    // Ignore whitespace
                } else {
                    latex += convertBlock(block, isUnit);
                }
            }
            return latex;
        }

        function tokenize(text) {
            const tokens = [];
            const length = text.length;
            let i = 0;

            while (i < length) {
                const char = text[i];

                // Handle numbers
                const numberMatch = text.slice(i).match(/^\d+(,\d+)*(\.\d+(,\d+)*)?([eE][+-]?\d+)?/);
                if (numberMatch) {
                    tokens.push({ type: 'number', value: numberMatch[0] });
                    i += numberMatch[0].length;
                    continue;
                }

                // Handle escaped characters
                if (char === '\\') {
                    const escapeMatch = text.slice(i).match(/^\\[a-zA-Z0-9]+/);
                    if (escapeMatch) {
                        tokens.push({ type: 'variable', value: escapeMatch[0] });
                        i += escapeMatch[0].length;
                        continue;
                    } else if (text[i + 1] === '{') {
                        tokens.push({ type: 'variable', value: '\\{' });
                        i += 2;
                        continue;
                    } else if (text[i + 1] === '}') {
                        tokens.push({ type: 'variable', value: '\\}' });
                        i += 2;
                        continue;
                    }
                }

                // Handle operators
                const operatorMatch = text.slice(i).match(/^[\+\-\*\/\^_]/);
                if (operatorMatch) {
                    tokens.push({ type: 'operator', value: operatorMatch[0] });
                    i += operatorMatch[0].length;
                    continue;
                }

                // Handle special functions
                const specialFunctionMatch = text.slice(i).match(/^(sin|cos|log|ln|sum|int|sqrt|abs|arccos|arcsin|arctan|arg|cosh|cot|coth|csc|deg|det|dim|exp|gcd|hom|inf|ker|lg|lim|liminf|limsup|max|min|Pr|sec|sinh|sup|tan|tanh)\{/);
                if (specialFunctionMatch) {
                    const functionName = specialFunctionMatch[1];
                    const subEq = [];
                    let braceCount = 1;
                    let braceContent = '';
                    i += specialFunctionMatch[0].length;

                    while (braceCount != 0 && i < length) {
                        const braceChar = text[i];
                        if (braceChar === '{') {
                            braceCount++;
                        } else if (braceChar === '}') {
                            braceCount--;
                        }
                        if (braceCount > 0) {
                            braceContent += braceChar;
                        }
                        i++;
                        if (braceCount === 0) {
                            subEq.push(tokenize(braceContent));

                            if (text[i] !== '{') {

                                break;
                            } else {
                                i++
                                braceCount = 1
                                braceContent = ''
                            }
                        }
                    }
                    tokens.push({ type: 'function', name: functionName, sub_eq: subEq });
                    continue;
                }

                // Handle curly braces
                if (char === '{') {
                    let braceContent = '';
                    let braceCount = 1;
                    i++;

                    while (i < length) {
                        const braceChar = text[i];
                        if (braceChar === '{') {
                            braceCount++;
                        } else if (braceChar === '}') {
                            braceCount--;
                        }
                        if (braceCount > 0) {
                            braceContent += braceChar;
                        }
                        i++;
                        if (braceCount === 0) {

                            tokens.push({ type: 'sub_eq', type: 'braces', blocks: tokenize(braceContent) });

                            break;
                        }
                    }
                    continue;
                }

                // Handle square brackets
                if (char === '[') {
                    let bracketContent = '';
                    let bracketCount = 1;
                    i++;

                    while (i < length) {
                        const bracketChar = text[i];
                        if (bracketChar === '[') {
                            bracketCount++;
                        } else if (bracketChar === ']') {
                            bracketCount--;
                        }
                        if (bracketCount > 0) {
                            bracketContent += bracketChar;
                        }
                        i++;
                        if (bracketCount === 0) {
                            tokens.push({ type: 'sub_eq', type: 'brackets', blocks: tokenize(bracketContent), is_unit: true });
                            break;
                        }
                    }
                    continue;
                }

                // Handle equal signs and other operators
                const operatorMatch2 = text.slice(i).match(/^(=|<=|>=|<|>|\\neq|\\or|\\vee|\\and|\\wedge)/);
                if (operatorMatch2) {
                    tokens.push({ type: 'operator', value: operatorMatch2[0] });
                    i += operatorMatch2[0].length;
                    continue;
                }

                // Handle text blocks
                if (char === '"') {
                    let textBlock = '';
                    let escape = false;
                    i++;
                    while (i < length) {
                        const textChar = text[i];
                        if (textChar === '\\' && !escape) {
                            escape = true;
                        } else {
                            if (textChar === '"' && !escape) {
                                i++;
                                tokens.push({ type: 'text', value: textBlock });
                                break;
                            } else {
                                textBlock += textChar;
                                escape = false;
                            }
                        }
                        i++;
                    }
                    continue;
                }

                // Handle spaces
                if (/\s/.test(char)) {
                    tokens.push({ type: 'whitespace', value: char });
                    i++;
                    continue;
                }

                // Handle anything else as a variable
                const variableMatch = text.slice(i).match(/^[a-zA-Z]+[a-zA-Z0-9'\{\}]*/);
                if (variableMatch) {
                    tokens.push({ type: 'variable', value: variableMatch[0] });
                    i += variableMatch[0].length;
                    continue;
                }

                // Handle anything else as a variable
                tokens.push({ type: 'variable', value: char });
                i++;
            }
            return tokens;
        }

        function textToLatex(text) {
            try {
                return convertBlocksToLatex(tokenize(text));
            } catch (error) {
                console.error("Error during conversion:", error);
                throw error;  // Re-throw the error to be caught in the updatePreview function
            }
        }

        function tokenizeLatex(latex) {
            let tokens = [];
            let i = 0;
            const len = latex.length;

           // Helper: parse a group delimited by { and } (allowing nesting)
            function parseParenthesesGroup() {
                i++; // Skip the opening {
                let content = "";
                let depth = 1;
                while (i < len && depth > 0) {
                    if (latex[i] === "(") {
                        depth++;
                        content += latex[i];
                        i++;
                    } else if (latex[i] === ")") {
                        depth--;
                        if (depth > 0) {
                            content += latex[i];
                        }
                        i++;
                    } else {
                        content += latex[i];
                        i++;
                    }
                }
                // Recursively tokenize the inner content.
                return tokenizeLatex(content);
            }

            // Helper: parse a group delimited by { and } (allowing nesting)
            function parseCurlyGroup() {
                i++; // Skip the opening {
                let content = "";
                let depth = 1;
                while (i < len && depth > 0) {
                    if (latex[i] === "{") {
                        depth++;
                        content += latex[i];
                        i++;
                    } else if (latex[i] === "}") {
                        depth--;
                        if (depth > 0) {
                            content += latex[i];
                        }
                        i++;
                    } else {
                        content += latex[i];
                        i++;
                    }
                }
                // Recursively tokenize the inner content.
                return tokenizeLatex(content);
            }

            // Helper: parse a group delimited by [ and ] (allowing nesting)
            function parseSquareGroup() {
                i++; // Skip the opening [
                let content = "";
                let depth = 1;
                while (i < len && depth > 0) {
                    if (latex[i] === "[") {
                        depth++;
                        content += latex[i];
                        i++;
                    } else if (latex[i] === "]") {
                        depth--;
                        if (depth > 0) {
                            content += latex[i];
                        }
                        i++;
                    } else {
                        content += latex[i];
                        i++;
                    }
                }
                return tokenizeLatex(content);
            }
            /* detectNumber scans text starting at index “start”
            and tries to pick up a token matching:
            {n digit number}
            {optional: (dot or comma) or { (dot or comma) } followed by one or more digits}
            {optional: whitespace, then "\cdot", whitespace, "10", whitespace, "^", "{", optional sign, digits, "}"}
            It returns null if the first character isn’t a digit.
            Otherwise it returns an object with { value: <token-string>, newIndex: <position after the token> } */
            function detectNumber(text, start) {
                let i = start,
                    n = text.length;
                let res = "";

                // helper: returns true if ch is a digit
                function isDigit(ch) {
                    return ch >= "0" && ch <= "9";
                }

                // --- Parse the integer part (must have at least one digit) ---
                let integerPart = "";
                while (i < n && isDigit(text[i])) {
                    integerPart += text[i];
                    i++;
                }
                if (integerPart === "") return null; // no digit found at start
                res += integerPart;

                // --- Parse optional decimal separator and fraction ---
                // We allow either a dot or comma (or a {dot/comma} form)
                let separator = "";
                let fraction = "";
                if (i < n) {
                    if (text[i] === "." || text[i] === ",") {
                        separator = text[i];
                        i++;
                        let fracStart = i;
                        while (i < n && isDigit(text[i])) {
                            fraction += text[i];
                            i++;
                        }
                        // If no digit follows the separator, we “roll back”
                        if (fraction === "") {
                            i = fracStart - 1; // back up over the separator
                            separator = "";
                        }
                    } else if (text[i] === "{" && i + 2 < n && (text[i + 1] === "." || text[i + 1] === ",") && text[i + 2] === "}") {
                        separator = text[i + 1];
                        i += 3;
                        let fracStart = i;
                        while (i < n && isDigit(text[i])) {
                            fraction += text[i];
                            i++;
                        }
                        if (fraction === "") {
                            i = fracStart - 3; // rollback the whole brace pattern
                            separator = "";
                        }
                    }
                }
                if (separator !== "") {
                    res += separator + fraction;
                }

                // --- Look for an optional exponent part ---
                // Save where we are before “consuming” whitespace for the exponent:
                let savedIndex = i;
                while (i < n && /\s/.test(text[i])) {
                    i++;
                } // skip white space

                var next_exp = "\\cdot"
                if (text.slice(i, i + next_exp.length) === next_exp) {
                    let expStr = "";
                    // (Include any whitespace that was skipped if you wish)
                    expStr += text.slice(savedIndex, i);
                    expStr += text.slice(i, i + next_exp.length); // the "\cdot"
                    i += next_exp.length;


                    // Skip whitespace after "\cdot"
                    while (i < n && /\s/.test(text[i])) {
                        expStr += text[i];
                        i++;
                    }


                    // Expect "10"
                    if (text.slice(i, i + 2) !== "10") {
                        i = savedIndex; // exponent part not valid, so back out
                        return {
                            value: res,
                            newIndex: i
                        };
                    }
                    expStr += "10";
                    i += 2;

                    while (i < n && /\s/.test(text[i])) {
                        expStr += text[i];
                        i++;
                    }
                    // Expect a caret '^'
                    if (i < n && text[i] === "^") {
                        expStr += "^";
                        i++;
                    } else {
                        i = savedIndex;
                        return {
                            value: res,
                            newIndex: i
                        };
                    }
                    // Expect an opening brace '{'
                    if (i < n && text[i] === "{") {
                        expStr += "{";
                        i++;
                    } else {
                        i = savedIndex;
                        return {
                            value: res,
                            newIndex: i
                        };
                    }
                    // Read an exponent number: optional "+" or "-" then at least one digit
                    let expDigits = "";
                    if (i < n && (text[i] === "+" || text[i] === "-")) {
                        expDigits += text[i];
                        expStr += text[i];
                        i++;
                    }
                    if (i < n && isDigit(text[i])) {
                        while (i < n && isDigit(text[i])) {
                            expDigits += text[i];
                            expStr += text[i];
                            i++;
                        }
                    } else {
                        i = savedIndex;
                        return {
                            value: res,
                            newIndex: i
                        };
                    }
                    // Expect a closing brace '}'
                    if (i < n && text[i] === "}") {
                        expStr += "}";
                        i++;
                    } else {
                        i = savedIndex;
                        return {
                            value: res,
                            newIndex: i
                        };
                    }
                    // Append the valid exponent part:
                    res += expStr;
                } else {
                    // No exponent part: revert to savedIndex so that any whitespace skipped isn’t “eaten”
                    i = savedIndex;
                }

                return {
                    value: res,
                    newIndex: i
                };
            }

            /* convertToScientificFormat takes one of the tokens produced by detectNumber
            and returns a converted version:
            • When there is no exponent part, it replaces any dot with a comma.
            • When an exponent was found (look for "\cdot"), it extracts the exponent number
            and returns:  {base} + "E" + {exponent number}
        
            Examples:
            "3"                → "3"
            "3,4"              → "3,4"
            "3{,}4" (detected as "3,4") → "3,4"
            "10.10"            → "10,10"
            "10.10 \cdot 10^{-10}"  → "10.10E-10"
            */
            function convertToScientificFormat(numStr) {
                if (numStr == null) return null;
                // If there is an exponent part, look for "\cdot"
                if (numStr.indexOf("\\cdot") !== -1) {
                    // Let the base be what comes before "\cdot":
                    let base = numStr.slice(0, numStr.indexOf("\\cdot")).trim();
                    // In the exponent part we expect a pattern like: "\cdot 10^{...}"
                    // We simply locate the first "{" and the last "}" and extract what is between.
                    let braceOpen = numStr.indexOf("{");
                    let braceClose = numStr.lastIndexOf("}");
                    if (braceOpen !== -1 && braceClose !== -1 && braceClose > braceOpen) {
                        let exponent = numStr.substring(braceOpen + 1, braceClose);
                        return base + "E" + exponent;
                    } else {
                        return numStr; // not as expected; return the original string
                    }
                } else {
                    // No exponent part: simply change every dot into a comma.
                    // (If you want to change only the first occurrence, you might use replace; here we convert all.)
                    return numStr.split(".").join(",");
                }
            }


            // Main loop: iterate through the LaTeX string
            while (i < len) {
                let ch = latex[i];

                // Handle whitespace (we preserve it as its own tokens)
                if (/\s/.test(ch)) {
                    tokens.push({
                        type: "whitespace",
                        value: ch
                    });
                    i++;
                    continue;
                }

                // Special: division formatted as \dfrac{numerator}{denominator}
                if (latex.slice(i).startsWith("\\dfrac")) {
                    i += "\\dfrac".length;
                    // Skip any intervening whitespace
                    while (i < len && /\s/.test(latex[i])) {
                        i++;
                    }
                    let numerator = [];
                    if (latex[i] === "{") {
                        numerator = parseCurlyGroup();
                    }
                    while (i < len && /\s/.test(latex[i])) {
                        i++;
                    }
                    let denominator = [];
                    if (latex[i] === "{") {
                        denominator = parseCurlyGroup();
                    }
                    tokens.push({
                        type: "operator",
                        value: "/",
                        numerator: numerator,
                        denominator: denominator
                    });
                    continue;
                }

                // Special: multiplication formatted as \cdot (our forward conversion uses it for '*')
                if (latex.slice(i).startsWith("\\cdot")) {
                    tokens.push({
                        type: "operator",
                        value: "*"
                    });
                    i += "\\cdot".length;
                    continue;
                }

                // Special: text block formatted as \text{...}
                if (latex.slice(i).startsWith("\\text{")) {
                    i += "\\text{".length;
                    let textContent = "";
                    let depth = 1;
                    while (i < len && depth > 0) {
                        if (latex[i] === "{") {
                            depth++;
                            textContent += latex[i];
                            i++;
                        } else if (latex[i] === "}") {
                            depth--;
                            if (depth > 0) {
                                textContent += latex[i];
                            }
                            i++;
                        } else {
                            textContent += latex[i];
                            i++;
                        }
                    }
                    tokens.push({
                        type: "text",
                        value: textContent
                    });
                    continue;
                }

                // Special: functions – they start with a backslash followed by alphabetic letters.
                if (ch === "\\") {
                    let funcMatch = latex.slice(i).match(/^\\[a-zA-Z]+/);
                    if (funcMatch) {
                        let fullCmd = funcMatch[0];
                        let funcName = fullCmd.slice(1); // remove the backslash

                        // List of special functions as defined in the formatting instructions.
                        let specialFunctions = [
                            "sin", "cos", "log", "ln", "sum", "int", "sqrt", "abs",
                            "arcsin", "arctan", "arccos", "arg", "cos", "cosh", "cot", "coth",
                            "csc", "deg", "det", "dim", "exp", "gcd", "hom", "inf", "ker", "lg",
                            "lim", "liminf", "limsup", "max", "min", "Pr", "sec", "tan", "tanh", "sup"
                        ];

                        // If the command is one of our special functions, process its groups.
                        if (specialFunctions.includes(funcName)) {
                            i += fullCmd.length; // Consume the function command
                            let sub_eq = [];
                            // Check for optional superscript (^) and subscript (_) groups.
                            while (i < len && (latex[i] === "_" || latex[i] === "^")) {
                                let op = latex[i];
                                i++; // consume '_' or '^'

                                if (latex[i] === "{") {
                                    let groupTokens = parseCurlyGroup();
                                    sub_eq.push({
                                        type: op === "_" ? "subscript" : "superscript",
                                        blocks: groupTokens
                                    });
                                }
                            }
                            // Now, check for the main argument group (if present).
                            if (i < len && latex[i] === "{") {
                                let groupTokens = parseCurlyGroup();
                                sub_eq.push({
                                    type: "argument",
                                    blocks: groupTokens
                                });
                            }
                            // Now, check for the main argument group (if present).
                            if (i < len && latex[i] === "(") {
                                let groupTokens = parseParenthesesGroup();
                                if (groupTokens.length == 1 && groupTokens[0].type == 'braces'){
                                    groupTokens = groupTokens[0].blocks
                                }
                                sub_eq.push({
                                    type: "argument",
                                    blocks: groupTokens
                                });
                            }
                            tokens.push({
                                type: "function",
                                name: funcName,
                                sub_eq: sub_eq
                            });
                            continue;
                        } else {
                            // Not a special function? Could be a special variable like \pi, or an operator command.
                            tokens.push({
                                type: "variable",
                                value: fullCmd
                            });
                            i += fullCmd.length;
                            continue;
                        }
                    }
                }

                // If we see an opening curly brace, treat it as a subequation wrapped in braces.
                if (ch === "{") {
                    let groupTokens = parseCurlyGroup();
                    tokens.push({
                        type: "braces",
                        blocks: groupTokens
                    });
                    continue;
                }

                // If we see an opening square bracket, that indicates a unit/tags group.
                if (ch === "[") {
                    let groupTokens = parseSquareGroup();
                    tokens.push({
                        type: "brackets",
                        blocks: groupTokens,
                        is_unit: true
                    });
                    continue;
                }

                // Check for numbers.
                // Expected pattern: one or more digits, optionally with a "{,}" as a decimal separator,
                // and optionally an exponent formatted as " \cdot 10^{...}".
                const response = detectNumber(latex, i);

                if (response) {
                    tokens.push({
                        type: "number",
                        value: convertToScientificFormat(response.value)
                    });
                    i = response.newIndex;
                    continue;
                }


                // Check for equallike operators – note the multi‐character operators are prioritized.
                const opList = ["<=", ">=", "\\neq", "\\or", "\\vee", "\\and", "\\wedge", "=", "<", ">", "+", "-", "*", "/", "^", "_"];
                let opFound = false;
                for (let op of opList) {
                    if (latex.slice(i, i + op.length) === op) {
                        tokens.push({
                            type: "operator",
                            value: op
                        });
                        i += op.length;
                        opFound = true;
                        break;
                    }
                }
                if (opFound) continue;

                // Otherwise, treat contiguous letters/digits (and apostrophes, backslashes) as a variable.
                let varMatch = latex.slice(i).match(/^[a-zA-Z0-9']+/);
                if (varMatch) {
                    tokens.push({
                        type: "variable",
                        value: varMatch[0]
                    });
                    i += varMatch[0].length;
                    continue;
                }

                // If nothing else matches, push the single character as a variable token.
                tokens.push({
                    type: "variable",
                    value: ch
                });
                i++;
            }
            return tokens;
        }

        function blockToText(tokens) {
            var output = "";


            const addToOutput = (text) => {

                output += text;

                
            }

            for (var i = 0; i < tokens.length; i++) {
                var token = tokens[i];

                // If it is a text block then accumulate its conversion.
                if (token.type === "text") {
                    addToOutput('"'+token.value+'"')
                } else {
                    // Before handling any non-text token, flush out any text we've accumulated.
                    if (token.type === "whitespace") {
                        addToOutput(token.value);
                    } else if (token.type === "operator") {
                        switch (token.value) {
                            case "/":

                                addToOutput(" {" + blockToText(token.numerator) + "}/{" + blockToText(token.denominator) + "} ");

                                break;

                            default:
                                addToOutput(token.value);

                                break;
                        }
                    } else if (token.type === "variable") {
                        addToOutput(token.value)
                    } else if (token.type === "number") {
                        let input = token.value;

                        // Replace 3{,}4 \cdot 10^{-2} with 3,4E-2
                        input = input.replace(/(\d+)\{,\}(\d+) \\cdot 10\^{(-?\d+)}/g, '$1,$2E$3');

                        // Replace 3 \cdot 10^{-4} with 3E-4
                        input = input.replace(/(\d+) \\cdot 10\^{(-?\d+)}/g, '$1E$2');

                        // Replace 3{,}3 with 3,3
                        input = input.replace(/(\d+)\{,\}(\d+)/g, '$1,$2');

                        // Replace 3,3 with 3,3 (no change needed, but included for completeness)
                        // input = input.replace(/(\d+),(\d+)/g, '$1,$2'); // This line is redundant

                        // Replace 3.3 with 3.3 (no change needed, but included for completeness)
                        // input = input.replace(/(\d+)\.(\d+)/g, '$1.$2'); // This line is redundant
                        addToOutput(input);
                    } else if (token.type === "braces") {
                        // Convert inner blocks and wrap with { ... }.
                        const text = blockToText(token.blocks)

                        addToOutput("{" + text + "}")
                    } else if (token.type === "brackets") {
                        const text = blockToText(token.blocks)
                        addToOutput("[" + text + "]")

                        // Convert inner blocks and wrap with [ ... ]. (This is our “square braces correctly” rule.)
                    } else if (token.type === "function") {
                        // Convert function tokens by outputting the backslash plus name,
                        // then each of its sub_equation groups.
                        var funcStr = token.name;
                        if (token.sub_eq && token.sub_eq.length > 0) {
                            var is_texts = []
                            token.sub_eq.forEach(function (sub) {
                                const text = blockToText(sub.blocks, true)

                                if (sub.type === "subscript") {
                                    funcStr += "{" + text + "}";
                                } else if (sub.type === "superscript") {
                                    funcStr += "{" + text + "}";
                                } else if (sub.type === "argument") {
                                    funcStr += "{" + text + "}";
                                }
                            });
                        }
                        addToOutput(funcStr)
                    } else {
                        addToOutput(token.value || "")
                        // Anything else: if there is some value, just output it.
                    }
                }
            }

            // Flush any remaining accumulated text.
            return output;

        }

        function latexToText(latex){
            return blockToText(tokenizeLatex(latex));
        }

        const input = document.getElementById('input');
        const katexOutput = document.getElementById('katex-output');
        const rawTexOutput = document.getElementById('raw-tex-output');
        const textOutput = document.getElementById('text-output');
        const errorMessage = document.getElementById('error-message');
        const tokens = document.getElementById('block-data');

        function updatePreview() {
            const inputText = input.value;
            errorMessage.textContent = ''; // Clear previous error message


            try {
                const tokens = tokenize(inputText);
                console.log('latex: ', tokens)
                tokens.textContent = JSON.stringify(tokens, null, 2);
                const latex = textToLatex(inputText);
                rawTexOutput.textContent = latex;
                const text_tokens = tokenizeLatex(latex);
                console.log('text: ', text_tokens)
                textOutput.textContent = blockToText(text_tokens);
                katex.render(latex, katexOutput, {
                    throwOnError: false,
                    displayMode: true // Improved display
                });
            } catch (error) {
                errorMessage.textContent = "Error: " + error.message;
            }
        }

        input.addEventListener('input', updatePreview);

        // Initial render
        updatePreview();
    </script>
</body>

</html>